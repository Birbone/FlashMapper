<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
	var maxNumberOfSources = 14;
	var sourceTypePrefix = "Source";
	var sourceLambdaArgumentPrefix = "s";
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq.Expressions;
using FlashMapper.Internal.Utils;
using FlashMapper.Models;
using FlashMapper.MultiSource;
using FlashMapper.Services;

namespace FlashMapper.DependancyInjection
{
<#  for (var i = 0; i < maxNumberOfSources; i++)
    {
		var sourcesTypesString = string.Join(", ", Enumerable.Range(1, i + 1)
			.Select(n => $"T{sourceTypePrefix}{n}"));
		var sourcesLambdaArgumentsString = string.Join(", ", Enumerable.Range(1, i + 1)
			.Select(n => $"{sourceLambdaArgumentPrefix}{n}"));
#>
	internal class DeferredFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination>, IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination> This => this;

        public IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination> AfterMap(Action<<#= sourcesTypesString#>, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<<#= sourcesTypesString#>, TDestination> BeforeMap(Action<<#= sourcesTypesString#>, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<<#= sourcesTypesString#>, TBuilder, TDestination> ToInternalCallback(Action<<#= sourcesTypesString#>, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (<#=sourcesLambdaArgumentsString#>, b, d) => { callback.Method.Invoke(b, new object[] { <#=sourcesLambdaArgumentsString#>, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (<#=sourcesLambdaArgumentsString#>, b, d) => callback(<#=sourcesLambdaArgumentsString#>, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (<#=sourcesLambdaArgumentsString#>, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {<#=sourcesLambdaArgumentsString#>, d});
            };
        }
    }
<#  } #>
}