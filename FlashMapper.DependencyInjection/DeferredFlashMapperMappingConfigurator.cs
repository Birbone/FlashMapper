//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq.Expressions;
using FlashMapper.Internal.Utils;
using FlashMapper.Models;
using FlashMapper.MultiSource;
using FlashMapper.Services;

namespace FlashMapper.DependencyInjection
{
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TDestination>, IFlashMapperMappingConfigurator<TSource1, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TDestination> AfterMap(Action<TSource1, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TDestination> BeforeMap(Action<TSource1, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, b, d) => { callback.Method.Invoke(b, new object[] { s1, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, b, d) => callback(s1, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TDestination> AfterMap(Action<TSource1, TSource2, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TDestination> BeforeMap(Action<TSource1, TSource2, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, b, d) => callback(s1, s2, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, b, d) => callback(s1, s2, s3, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, b, d) => callback(s1, s2, s3, s4, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, b, d) => callback(s1, s2, s3, s4, s5, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, b, d) => callback(s1, s2, s3, s4, s5, s6, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, d});
            };
        }
    }
	internal class DeferredFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination, TBuilder>: 
        DeferredFlashMapperMappingConfiguratorBase<IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TBuilder, TDestination>>, IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination>
    {
        private readonly TBuilder builder;

        public DeferredFlashMapperMappingConfigurator(TBuilder builder)
        {
            this.builder = builder;
        }

        protected override IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> This => this;

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> AfterMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> afterMapCallback)
        {
            ApplyBuilderMethod(nameof(AfterMap), ma(ToInternalCallback(afterMapCallback)));
            return This;
        }

        public IFlashMapperMappingConfigurator<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> BeforeMap(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> beforeMapCallback)
        {
            ApplyBuilderMethod(nameof(BeforeMap), ma(ToInternalCallback(beforeMapCallback)));
            return This;
        }

        private Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TBuilder, TDestination> ToInternalCallback(Action<TSource1, TSource2, TSource3, TSource4, TSource5, TSource6, TSource7, TSource8, TSource9, TSource10, TSource11, TSource12, TSource13, TSource14, TDestination> callback)
        {
            if (builder.Equals(callback.Target))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, b, d) => { callback.Method.Invoke(b, new object[] { s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, d }); };

            if (callback.Target == null || !DeferredFlashMapperMappingConfiguratorHelpers.IsClosure(callback.Target, builder))
                return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, b, d) => callback(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, d);

            DeferredFlashMapperMappingConfiguratorHelpers.GetClosureDefinition(callback.Target, builder, out var targetType, out var thisFields, out var otherFields);
            return (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, b, d) =>
            {
                var newTarget = DeferredFlashMapperMappingConfiguratorHelpers.CloneClosure(targetType, thisFields, otherFields, b);
                callback.Method.Invoke(newTarget, new object[] {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, d});
            };
        }
    }
}